using System;
using System.ComponentModel;
using System.IO;
using System.Runtime.InteropServices;
using MalwareScanner.Contracts;

namespace MalwareScanner.Scanners.Amsi
{
	public class AmsiMalwareScanner : IMalwareScanner, IDisposable
	{
		private const uint MaxSizeOfContentToBeScanned = uint.MaxValue;
		private const string AppIdentifier = "LTA-Malware-Scanner";

		private bool disposed;
		private AmsiContextSafeHandle contextHandle;

		public AmsiMalwareScanner()
		{
			AmsiContextSafeHandle handle;
			int pInvokeResult = AmsiNativeMethods.AmsiInitialize(AppIdentifier, out handle);
			if (pInvokeResult != 0 || handle.IsInvalid)
			{
				throw new MalwareScanningException(
					"Failed to initialize AMSI context. For more details see inner exception.",
					new Win32Exception(Marshal.GetLastWin32Error()));
			}

			this.contextHandle = handle;
		}

		public IMalwareScanningResult Scan(Func<Stream> getFileFunc, string fileName = null)
		{
			if (this.disposed)
			{
				throw new ObjectDisposedException("AMSI context is closed.");
			}

			AMSI_RESULT result;
			using (Stream s = getFileFunc())
			{
				if (s.Length > MaxSizeOfContentToBeScanned)
				{
					throw new MalwareScanningException(string.Format(
						"Content is too big to be scanned ({0} bytes).The maximum allowed size is {1} bytes)", 
						s.Length, 
						MaxSizeOfContentToBeScanned));
				}

				using (MemoryStream ms = new MemoryStream())
				{
					s.CopyTo(ms);

					var contentLength = (uint)s.Length;
					byte[] contentBuffer = ms.ToArray();
					fileName = fileName ?? "file-" + Guid.NewGuid();
					AmsiNativeMethods.AmsiScanBuffer(this.contextHandle, contentBuffer, contentLength, fileName, IntPtr.Zero, out result);
				}
			}

			return new AmsiMalwareScanningResult(result);
		}

		public void Dispose()
		{
			// Dispose of unmanaged resources.
			this.Dispose(true);

			// Suppress finalization.
			GC.SuppressFinalize(this);
		}

		// The disposing parameter indicates whether the method call comes from a Dispose method (its value is true) or from a finalizer (its value is false)
		protected virtual void Dispose(bool disposing)
		{
			if (this.disposed)
			{
				return;
			}

			// A block that frees unmanaged resources. This block executes regardless of the value of the disposing parameter.

			// A conditional block that frees managed resources. This block executes if the value of disposing is true.
			if (disposing)
			{
				if (this.contextHandle != null && !this.contextHandle.IsInvalid)
				{
					// Free the handle
					this.contextHandle.Dispose();
				}
			}

			this.disposed = true;
		}
	}
}
